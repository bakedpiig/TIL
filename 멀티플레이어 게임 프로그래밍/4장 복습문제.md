### 1번 문제
---
vtable을 비롯한 포인터나 내부 구조를 명시하지 않는 vector와 같은 타입의 필드를 그대로 복사하기 때문이다.
### 2번 문제
---
엔디언은 플랫폼이 바이트를 저장하는 순서의 방식을 말한다. 플랫폼과의 엔디언 방식이 다를 수 있기 때문에 직렬화할 때 네트워크의 엔디언 방식에 맞춰서 직렬화한 다음, 데이터를 받을 때는 플랫폼의 엔디언 방식에 따라서 바꾼다.
### 3번 문제
---
자료구조의 길이와 함께 빈 공간을 제외한 데이터를 직렬화하여 보낸다.
### 4번 문제
---
포인터가 가리키는 객체를 직렬화해서 집어넣는 임베딩과 객체마다 고유 ID를 할당하고 네트워크상에 전송하여 ID와 객체를 링킹이라는 방법이 있다. 임베딩은 다른 객체와 공유되지 않는 필드밖에 없을 때 사용할 수 있으며 링킹은 공유되는 상황이 있을 때 사용할 수 있다.
### 5번 문제
---
엔트로피 인코딩은 데이터 압축에 있어 출현하는 데이터의 예측 가능성 정도에 따라 압축률이 달라진다는 이론이다. 예를 들어, 중력의 영향을 받는 객체의 y좌표를 압축할 때 사용할 수 있다.
### 6. 부동소수점 숫자를 직렬화할 때 대역폭을 절약하는 방법으로 고정소수점으로 변환하는 방법을 설명해 보자.
---
부동소수점을 사용하는 곳에서의 정밀도, 최솟값, 최댓값을 이용해서 각각의 값과 대응되는 상수를 네트워크로 전달한다.
### 7번 문제
---
`WirteBits()`는 엔디언에 따라서 바이트를 변환하는 코드가 없기 때문이다. 변경점은 `OutputMemoryBitStream.cpp` 참고
### 8번 문제
---
`OutputMemoryStream` 참고
### 9번 문제
---
`InputMemoryStream` 참고
### 10번 문제
---
`InputMemoryStream` 참고
### 11번 문제
---
`Affine.h`, `OutputMemoryStream`, `InputMemoryStream` 참고
### 12번 문제
---
어떻게 해야 되는지 모르겠다.ㅜ