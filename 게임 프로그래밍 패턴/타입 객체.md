# 타입 객체
## 타입 객체의 용도
클래스 하나를 인스턴스별로 다른 객체형으로 표현할 수 있게 만들어 유연하게 만든다.

## 패턴
* 타입 객체 클래스와 타입 사용 객체 클래스를 정의한다.
* 타입 사용 객체는 자신의 타입을 나타내는 타입 객체를 참조한다.
* 인스턴스별로 다른 데이터는 타입 사용 객체에 저장하고 같은 타입끼리 공유하는 데이터/동작은 타입 객체에 저장한다.

## 써야 하는 상황
* 개발 언어의 타입 시스템이 유연하지 않다.
    * 나중에 어떤 타입이 필요할지 알 수 없다.
    * 코드 변경 없이 새로운 타입을 추가하거나 변경하고 싶다.

## 주의 사항
* 타입 객체는 직접 관리해야 한다.
* 타입 종속적 동작을 정의하기가 어렵다.
    * 동작 코드를 여러 개 정의해 놓고 타입 객체에 데이터에 따라서 선택하도록 할 수 있다.

## 예제
~~~cpp
//타입 객체
class Breed {
public:
    Breed(int health, const char* attack)
    : health_(health),
      attack_(attack) {}

    int getHealth() { return health_; }
    const char* getAttack() { return attack_; }

private:
    int health_;
    const char* attack_;
};

//타입 사용 객체
class Monster {
public:
    Monster(Breed& breed)
    : health_(breed.getHealth()),
      breed_(breed) {}
    const char* getAttack() { return breed_.getAttack(); }

private:
    int health_;
    Breed& breed_;
};
~~~

## 디자인 결정
* 타입 객체의 캡슐화 여부
    * 캡슐화
        * 다른 코드에 드러나지 않는다.
        * 타입 객체 메서드를 선택적으로 오버라이드할 수 있다.
        * 타입 객체 메서드를 전부 포워딩해야 한다.
    * 노출
        * 외부에서 타입 객체에 접근할 수 있다.
        * 복잡성이 증가한다.

* 타입 사용 객체의 생성 방법
    * 객체 생성 후 타입 객체 전달
        * 외부 코드에서 메모리 할당을 제어할 수 있다.
    * 타입 객체의 생성자 호출
        * 타입 객체에서 메모리 할당을 제어한다.

* 타입 변경 여부
    * 불가능
        * 코드 구현과 이해가 쉽다.
        * 디버깅이 쉽다.
    * 가능
        * 객체 생성 횟수가 줄어든다.
        * 기존 객체 상태와 새로운 타입의 요구사항을 고려해야 한다.

* 상속 지원 여부
    * 없음
        * 단순하다.
        * 중복 작업이 있을 수 있다.
    * 단일 상속
        * 다중 상속보다 단순하다.
        * 속성 값을 얻는 데 오래 걸린다.
    * 다중 상속
        * 거의 모든 데이터 중복을 피할 수 있다.
        * 복잡하다.